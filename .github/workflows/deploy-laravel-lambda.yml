name: Deploy to AWS ECR (Laravel → Lambda)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      run_migrations:
        description: "Run php artisan migrate --force via Artisan Lambda"
        type: boolean
        default: false

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # (Optional) If you build assets with Node (Vite/Mix), keep these three steps.
      # Otherwise, remove them.
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 18

      - name: Cache Node.js dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install frontend dependencies (optional)
        run: |
          if [ -f package.json ]; then
            npm ci
            # npm run build   # uncomment if you compile assets into /public
          fi

      # AWS creds (using long-lived keys like your example).
      # If you can, prefer OIDC in the future.
    #   - name: Configure AWS Credentials
    #     uses: aws-actions/configure-aws-credentials@v4
    #     with:
    #       aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
    #       aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #       aws-region:            ${{ secrets.AWS_REGION }}

    #   - name: Log in to Amazon ECR
    #     run: |
    #       aws ecr get-login-password --region ${{ secrets.AWS_REGION }} |
    #       docker login --username AWS --password-stdin ${{ secrets.ECR_REPOSITORY_URI }}

      # Build & tag image (Dockerfile should use Bref php-81-fpm like we discussed)
    #   - name: Build and tag Docker image
    #     run: |
    #       IMAGE_TAG=${{ secrets.ECR_REPOSITORY_URI }}:${{ github.sha }}
    #       docker build -t laravel-app .
    #       docker tag laravel-app:latest $IMAGE_TAG
    #       echo "IMAGE_TAG=$IMAGE_TAG" >> $GITHUB_ENV

      # (Optional) Peek inside the built image to sanity-check paths
    #   - name: List files in container image
    #     run: |
    #       docker run --rm --entrypoint "" ${{ env.IMAGE_TAG }} ls -al /var/task

    #   - name: Push Docker image to ECR
    #     run: |
    #       docker push ${{ env.IMAGE_TAG }}

      # Update the Lambda function to this new image
    #   - name: Update Lambda with new image
    #     run: |
    #       aws lambda update-function-code \
    #         --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
    #         --image-uri       ${{ env.IMAGE_TAG }} \
    #         --region          ${{ secrets.AWS_REGION }} >/dev/null
    #       echo "Lambda updated."
    #       aws lambda wait function-updated --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }}

      # (Optional) Update Lambda environment variables in case you changed any
      # UNCOMMENT and edit if you want CI to own env config:
      # - name: Update Lambda environment (optional)
      #   run: |
      #     aws lambda update-function-configuration \
      #       --function-name ${{ secrets.LAMBDA_FUNCTION_NAME }} \
      #       --environment "Variables={
      #         APP_ENV=production,
      #         APP_DEBUG=false,
      #         APP_URL=${{ secrets.APP_URL }},
      #         APP_KEY=${{ secrets.APP_KEY }},
      #         LOG_CHANNEL=stderr,
      #         LOG_LEVEL=error,
      #         APP_STORAGE=/tmp,
      #         CACHE_STORE=file,
      #         SESSION_DRIVER=cookie,
      #         QUEUE_CONNECTION=sync,
      #         FILESYSTEM_DISK=s3,
      #         AWS_DEFAULT_REGION=${{ secrets.AWS_REGION }},
      #         AWS_BUCKET=${{ secrets.AWS_BUCKET }},
      #         DB_CONNECTION=mysql,
      #         DB_HOST=${{ secrets.DB_HOST }},
      #         DB_PORT=3306,
      #         DB_DATABASE=${{ secrets.DB_DATABASE }},
      #         DB_USERNAME=${{ secrets.DB_USERNAME }},
      #         DB_PASSWORD=${{ secrets.DB_PASSWORD }}
      #       }" >/dev/null
      #     echo "Lambda environment updated."

      # (Optional) Run migrations by invoking a **separate** Artisan Lambda
      # This requires you to have an additional Lambda function that runs Bref console with CMD ["artisan"].
    #   - name: Run migrations (optional)
    #     if: ${{ inputs.run_migrations == true }}
    #     run: |
    #       PAYLOAD='{"command":"migrate","args":["--force"]}'
    #       aws lambda invoke \
    #         --function-name  ${{ secrets.ARTISAN_LAMBDA_NAME }} \
    #         --payload        "$PAYLOAD" \
    #         /tmp/migrate.json >/dev/null
    #       cat /tmp/migrate.json

      # (Optional) Invalidate CloudFront cache
    #   - name: Invalidate CloudFront Cache (optional)
    #     if: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID != '' }}
    #     run: |
    #       aws cloudfront create-invalidation \
    #         --distribution-id ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }} \
    #         --paths "/*" \
    #         --region ${{ secrets.AWS_REGION }}

      - name: Notify deployment success
        run: echo "✅ Deployment to ECR and Lambda successful!"
